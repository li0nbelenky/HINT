#!groovy?
import groovy.json.JsonOutput
def notifySlack(text, channel) {
    def slackURL = 'https://hooks.slack.com/services/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'
    def payload = JsonOutput.toJson([text  : text,
                                    channel   : channel,
                                    username  : "jenkins",
                                    icon_emoji: ":jenkins:"])
    sh "curl -X POST --data-urlencode \'payload=${payload}\' ${slackURL}"
}
def createPullRequest(url, text) {
    def payload = JsonOutput.toJson(text)
    sh "curl -n -X POST -H 'Content-Type: application/json' --data ${payload} ${url}"
}

node('hint-deployment-util'){
    try {

        notifySlack("STARTING ${env.JOB_NAME} ${env.BUILD_NUMBER}","#compliance-deployment")
        stage 'CHECKOUT'
        deleteDir()
        env.GIT_REPO='rproxy.ironsrc.com/scm/iavc/extractor.git'
        git branch: '**', credentialsId: 'cbca8cd9-3e58-4eb0-864e-1df1fbfee4f0', url: "https://${env.GIT_REPO}"

        stage 'SET ENVIRONMENT VARIABLES'
            withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId: 'cbca8cd9-3e58-4eb0-864e-1df1fbfee4f0', usernameVariable: 'GIT_USERNAME', passwordVariable: 'GIT_PASSWORD']]) {
                sh '''
                    set +e
                    set +x
                    echo env.GIT_USERNAME=${GIT_USERNAME} > env.properties
                    echo env.GIT_PASSWORD=${GIT_PASSWORD} >> env.properties
                    echo env.GIT_BRANCH=$(git rev-parse --abbrev-ref HEAD) >> env.properties
                    echo env.ORIGINAL_BRANCH=$(git rev-parse --abbrev-ref HEAD) >> env.properties
                    echo env.GIT_COMMIT=$(git rev-parse HEAD) >> env.properties
                    cat env.properties
                '''
            }

            sh '''
                sed 's/$/"/g' -i env.properties
                sed 's/=/="/g' -i env.properties
            '''

            sh 'cat web-server/infra/jenkins-env-variables.groovy >> env.properties'

            load ('env.properties')
            env.timestamp=(new Date()).toTimestamp().getTime()

        if (env.GIT_BRANCH =~ /^(staging|feature|test|bug)/){
            stage 'MERGE TO STAGING'
                if (env.GIT_BRANCH =~ /^(feature|test|bug)/) {
                    sh '''
                        git config user.name 'ci.infra'
                        git config user.email 'ci.infra@ironsource.com'
                        git checkout staging
                        git merge ${GIT_BRANCH}
                        echo env.GIT_COMMIT=$(git rev-parse HEAD) > merge.properties
                        echo env.GIT_BRANCH=$(git rev-parse --abbrev-ref HEAD) >> merge.properties
                        sed 's/$/"/g' -i merge.properties
                        sed 's/=/="/g' -i merge.properties
                    '''
                    load ('merge.properties')
                } else {
                   echo 'no need to merge to staging'
                }


            stage 'BUILDING IMAGE'
                ansiblePlaybook(
                        extras: '-c local -v',
                        playbook: 'web-server/infra/build-playbook.yml',
                        extraVars: [
                            commit: env.GIT_COMMIT,
                            image: env.DOCKER_REPO,
                            branch: env.GIT_BRANCH
                        ])


            stage 'RUN UNIT TESTS ON STAGING IMAGE'
                     echo 'here we will run tests'

            stage 'PUSH IMAGE TO REGISTRY'
                ansiblePlaybook(
                        extras: '-c local -v',
                        playbook: 'web-server/infra/push-to-docker-hub-playbook.yml',
                        extraVars: [
                            commit: env.GIT_COMMIT,
                            image: env.DOCKER_REPO,
                            branch: env.GIT_BRANCH
                        ])

            stage ('PUSH TO REMOTE STAGING BRANCH' ){
                      withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId: 'cbca8cd9-3e58-4eb0-864e-1df1fbfee4f0', usernameVariable: 'GIT_USERNAME', passwordVariable: 'GIT_PASSWORD']]) {
                          if (env.ORIGINAL_BRANCH =~ /^(feature|test|bug)/ ) {
                              sh '''
                                  git push https://${GIT_USERNAME}:${GIT_PASSWORD}@${GIT_REPO}
                              '''
                          } else {
                             echo 'no need to push to remote staging branch'
                          }
                      }
                    }

            stage 'DEPLOY'
                ansiblePlaybook(
                        playbook: 'web-server/infra/deploy-playbook.yml',
                        extras: '-i /etc/ansible/ec2.py -u ubuntu',
                        extraVars: [
                            commit: env.GIT_COMMIT,
                            image:  env.DOCKER_REPO,
                            service: env.COMPONENT,
                            branch: env.GIT_BRANCH,
                            hosts: env.ASG_staging
                        ])
            stage 'CREATE PULL REQUEST'
                if (env.GIT_BRANCH =~ /^staging/) {
                    createPullRequest(env.PUSHREQUEST_URL, env.PUSHREQUEST_TEXT)
                } else {
                    echo 'no need to create pull request'
                }

        } else if (env.GIT_BRANCH =~ /^master/) {

            stage 'BUILDING IMAGE'
                ansiblePlaybook(
                        extras: '-c local -v',
                        playbook: 'web-server/infra/build-playbook.yml',
                        extraVars: [
                            commit: env.GIT_COMMIT,
                            image: env.DOCKER_REPO,
                            branch: env.GIT_BRANCH
                        ])


            stage 'PUSH IMAGE TO REGISTRY'
                ansiblePlaybook(
                        extras: '-c local -v',
                        playbook: 'web-server/infra/push-to-docker-hub-playbook.yml',
                        extraVars: [
                            commit: env.GIT_COMMIT,
                            image: env.DOCKER_REPO,
                            branch: env.GIT_BRANCH
                        ])

            stage 'DEPLOY'
                ansiblePlaybook(
                        playbook: 'web-server/infra/deploy-playbook.yml',
                        extras: '-i /etc/ansible/ec2.py -u ubuntu',
                        extraVars: [
                            commit: env.GIT_COMMIT,
                            image:  env.DOCKER_REPO,
                            service: env.COMPONENT,
                            environment: env.GIT_BRANCH,
                            branch: env.GIT_BRANCH,
                            hosts: env.ASG_master
                        ])


        } else {

            echo 'branch is not supported'

        }

        currentBuild.result = 'SUCCESS'
        notifySlack("${currentBuild.result} ${env.JOB_NAME} ${env.BUILD_NUMBER}","#compliance-deployment")

    } catch(err){
        currentBuild.result = 'FAILURE'
        notifySlack("${currentBuild.result} ${env.JOB_NAME} ${env.BUILD_NUMBER}","#compliance-deployment")
        throw err
    }
}